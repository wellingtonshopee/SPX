<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Fila de Carregamento</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Basic reset and body styles - Ajustado PARA TER letreiros fixos */
        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Background padrão */
            overflow: hidden; /* Prevê scroll indesejado na página principal */
            height: 100vh; /* Full viewport height */
            display: flex; /* Flex container para layout de coluna */
            flex-direction: column; /* Stack children vertically */
            box-sizing: border-box; /* Include padding in height */
            /* Adiciona padding top/bottom para o espaço dos letreiros fixos NESTA página */
            padding-top: 30px; /* Altura do letreiro superior */
            padding-bottom: 30px; /* Altura do letreiro inferior */
        }

        /* >>> Estilos para os letreiros (topo e rodapé) <<< */
        .ticker-container {
            position: fixed; /* Fixa o container na tela */
            left: 0;
            right: 0;
            height: 30px; /* Altura do letreiro */
            overflow: hidden;
            z-index: 1000; /* Garante que fique acima de outros elementos */
            display: flex; /* Usa flexbox para alinhar itens horizontalmente */
            align-items: center; /* Centraliza itens verticalmente */
            padding: 0 10px;
            box-sizing: border-box;
            font-size: 1em;
            font-weight: bold;
            color: #fff; /* Texto branco para os letreiros */
        }

        /* Top Ticker (Azul) */
        #top-ticker {
            top: 0; /* Posiciona na parte superior */
            background-color: #3434eb; /* Azul */
        }

        /* Bottom Ticker (Vermelho) */
        #bottom-ticker {
            bottom: 0; /* Posiciona na parte inferior */
            background-color: #ff0000; /* Vermelho */
             /* Ajustes específicos para o letreiro inferior, se necessário */
        }

        .ticker-text {
            white-space: nowrap; /* Prevents text from wrapping */
            animation: scroll-left linear infinite; /* Scrolling animation */
            /* Animation duration should be set via JS or inline */
             /* Permite que o texto cresça horizontalmente dentro do flex container */
             flex-shrink: 0;
             flex-grow: 1; /* Ocupa espaço flexível */
             /* Adiciona margem para separar o texto das logos */
             margin: 0 10px; /* 10px de margem na esquerda e direita */
        }

         /* >>> NOVO ESTILO PARA AS LOGOS NOS LETREIROS <<< */
         .ticker-logo {
             height: 100%; /* Ocupa a altura total do ticker container */
             object-fit: contain; /* Garante que a imagem não seja distorcida */
             display: block; /* Remove espaço extra abaixo da imagem */
             flex-shrink: 0; /* Impede que a logo diminua */
         }


        /* Define the scrolling animation */
        @keyframes scroll-left {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
        }


        /* Main content area - Occupies space BETWEEN THE TICKERS */
        #main-content-area {
            flex-grow: 1; /* Occupies all available space vertically between tickers */
            position: relative; /* Parent for absolutely positioned children */
            /* Removed overflow: hidden; */
        }

        /* Container for Painel content (Quadro 1 and Quadro 2) */
        #painel-content {
            position: absolute; /* Layered over Midia content */
            top: 0;
            left: 0;
            width: 100%; /* Fill parent width */
            height: 100%; /* Fill parent height */
            display: flex; /* Use flex to lay out Quadro 1 and 2 */
            /* O display será controlado via JavaScript (flex/none) */
        }

        /* Container for Midia iframe */
        #midia-content {
            position: absolute; /* Layered, initially hidden */
            top: 0;
            left: 0;
            width: 100%; /* Fill parent width */
            height: 100%; /* Fill parent height */
            display: none; /* Inicialmente oculto */
            /* O display será controlado via JavaScript (block/none) */
        }

        #midia-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }


        /* Original .container styles - NOW INSIDE #painel-content */
        .container {
            display: flex;
            height: 100%; /* Fills #painel-content */
            transition: all 0.3s ease;
            width: 100%; /* Ensure it fills its parent */
        }

        /* Existing Quadro 1 & 2 styles (mantidos) */
        .quadro1 {
            background-color: #f2f2f2;
            padding: 20px;
            box-sizing: border-box;
            flex-grow: 0;
            transition: width 0.3s ease, flex-grow 0.3s ease;
            overflow-y: auto;
            width: calc(100% - 45%);
             /* >>> ESTILO DA MOLDURA PARA O QUADRO 1 <<< */
             border: 3px solid #df4102; /* Borda sólida azul, 3px de espessura */
             border-radius: 10px; /* Cantos levemente arredondados */
        }

        .quadro2 {
            background-color: #dcdcdc;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: width 0.3s ease, padding 0.3s ease;
            overflow-y: hidden;
            width: 45%;
        }

        /* Style for both Quadro titles */
        .quadro-titulo {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .colunas {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            flex: 1;
            overflow-y: auto;
            padding-bottom: 10px;
        }

        .coluna {
            flex: 1;
            min-width: 150px;
            background-color: #ffffff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .coluna h3 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }

        /* ESTILO PARA OS REGISTROS DENTRO DAS COLUNAS R (Quadro 2) */
        .registro {
            margin-bottom: 6px;
            padding: 8px;
            font-size: 0.9em;
            color: rgb(180, 7, 7);
            border: 1px solid red;
            border-radius: 4px;
            animation: blink 1s linear infinite;
            box-sizing: border-box;
            background-color: #fff0f0;
        }

         .registro:last-child {
             margin-bottom: 6px;
             padding-bottom: 8px;
             border-bottom: 1px solid red;
         }

        /* DEFINIÇÃO DA ANIMAÇÃO DE PISCAR (reutilizada para verde) */
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.2; }
            100% { opacity: 1; }
        }

        /* ESTILO PARA O CONTAINER DE REGISTROS NO QUADRO 1 (Layout 3 colunas) */
        #registrosEmSeparacaoContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        /* ESTILO PARA OS REGISTROS NO QUADRO 1 (Visual e Tamanho para 3 colunas) */
        .registro-quadro1 {
            width: calc(33.33% - 10px);
            box-sizing: border-box;

            /* Visual style - Verde Piscando */
            padding: 8px;
            border-radius: 4px;
            font-size: 0.95em;

            color: green;
            border: 1px solid green;
            background-color: #e0ffe0;
            animation: blink 1s linear infinite;

            margin: 0;
        }

        /* Mantém estilos internos do registro */
        .registro-quadro1 p {
            margin: 0 0 5px 0;
        }

        .registro-quadro1 p:last-child {
            margin-bottom: 0;
        }

        .registro-quadro1 strong {
            font-weight: bold;
            margin-right: 5px;
        }


        .rotulo {
            margin-bottom: 3px;
        }

        .hidden { /* Esta classe agora é usada apenas para esconder #quadro2 internamente se não houver dados relevantes */
            display: none;
            width: 0;
            padding: 0;
        }

        .error-message {
            color: red;
            text-align: center;
            margin-top: 20px;
        }

        /* Estilo para o botão de ativar som */
        #enable-sound-btn {
            position: fixed; /* Posição fixa na tela */
            top: 50%; /* Centraliza verticalmente */
            left: 50%; /* Centraliza horizontalmente */
            transform: translate(-50%, -50%); /* Ajusta para o centro exato */
            padding: 15px 30px;
            background-color: #007bff; /* Cor azul */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            z-index: 1001; /* Acima dos tickers */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: none; /* Inicialmente oculto, mostrado se o som precisar ser ativado */
        }

        #enable-sound-btn:hover {
            background-color: #0056b3; /* Azul mais escuro no hover */
        }


    </style>
</head>
<body>

    {# Top Ticker #}
    <div id="top-ticker" class="ticker-container">
        {# >>> Adicionando a Logo Antes do Texto <<< #}
        <img src="{{ url_for('static', filename='imagem/tvs.png') }}" alt="Logo 1" class="ticker-logo"> {# <-- SUBSTITUA O CAMINHO E ALT PELA SUA LOGA #}
        <div class="ticker-text" style="animation-duration: 180s;">{# AJUSTADO AQUI PARA 180 SEGUNDOS (3 MINUTOS) #}
            Carregando notícias...
        </div>
        {# >>> Adicionando a Logo Depois do Texto <<< #}
        <img src="{{ url_for('static', filename='imagem/tvs.png') }}" alt="Logo 2" class="ticker-logo"> {# <-- SUBSTITUA O CAMINHO E ALT PELA SUA LOGO #}
    </div>

    {# Main Content Area - This div holds the Painel OR Midia content #}
    {# It occupies the space BETWEEN THE TICKERS #}
    <div id="main-content-area">

        {# Container do Conteúdo do Painel (Quadros 1 e 2) - Inicialmente visível #}
        {# O display flex/none é controlado pelo JavaScript #}
        <div id="painel-content">
            {# Mantemos a div class="container" original com seus quadros dentro #}
            {# O display flex e height 100% aqui garantem que os quadros se comportem dentro de #painel-content #}
            <div class="container">
                <div class="quadro1" id="quadro1">
                    <div class="quadro-titulo">Carregamento Liberado - Mercadão</div>
                    <div id="registrosEmSeparacaoContainer">
                        <p style="text-align: center;">Carregando registros em separação...</p>
                    </div>
                </div>

                <div class="quadro2 hidden" id="quadro2">
                    <div class="quadro-titulo">Rotas No-Show - Aguardando Motorista</div>
                    <div class="colunas" id="colunasContainer">
                        <p style="text-align: center; width: 100%;">Carregando dados...</p>
                    </div>
                </div>
            </div>
        </div>

        {# Container do Conteúdo de Mídia (Iframe) - Inicialmente oculto #}
        {# O display block/none é controlado pelo JavaScript #}
        <div id="midia-content">
             <iframe id="midia-iframe" src="" style="width: 100%; height: 100%; border: none;"></iframe>
        </div>

    </div> {# Fim main-content-area #}


    {# Bottom Ticker - COM LOGO #}
    <div id="bottom-ticker" class="ticker-container">
         {# >>> Adicionando a Logo Antes do Texto <<< #}
         <img src="{{ url_for('static', filename='imagem/tvs.png') }}" alt="SPX" class="ticker-logo"> {# <-- SUBSTITUA O CAMINHO E ALT PELA SUA LOGO #}

         {# O texto rolante #}
         <div class="ticker-text" style="animation-duration: 60s;">{# Mantido em 60s para o inferior #}
             Carregando informações...
         </div>

         {# >>> Adicionando a Logo Depois do Texto <<< #}
         <img src="{{ url_for('static', filename='imagem/tvs.png') }}" alt="SPX" class="ticker-logo"> {# <-- SUBSTITUA O CAMINHO E ALT PELA SUA LOGO #}
    </div>

    {# Elemento de Áudio para Notificações #}
    <audio id="notification-audio" src="{{ url_for('static', filename='audio/spx.mp3') }}"  preload="auto"></audio> {# <-- SUBSTITUA O CAMINHO DO ÁUDIO AQUI #}

    {# Botão para Ativar o Som (inicialmente oculto) #}
    <button id="enable-sound-btn">Clique para Ativar o Som</button>


    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Variáveis de Estado Global e Timers ---
            let isShowingPainel = true; // Começa mostrando o Painel
            let painelTimer = null; // Timer para a duração do Painel
            let midiaTimer = null; // Timer para a duração da Mídia
            let lastEmSeparacaoRecordIds = []; // Para detectar novos registros no Quadro 1 "Em Separação" - Inicializado como array vazio
            let lastNoShowRecordIds = []; // Para detectar novos registros no Quadro 2 "No-Show" - Inicializado como array vazio
            let soundEnabled = false; // Estado para controlar se o som está ativado

            const PAINEL_DURATION = 90000; // 1 minuto em ms
            const MIDIA_DURATION = 30000; // 30 segundos em ms
            const FETCH_INTERVAL = 1000; // Intervalo de busca por novos registros (1 segundo)
            const NEWS_FETCH_INTERVAL = 180000; // Intervalo de busca de notícias (3 minutos)
            const OPERATIONAL_INFO_FETCH_INTERVAL = 30000; // Intervalo de busca de info operacional (30 segundos)


            // --- Obtém referências aos elementos ---
            const topTickerText = document.querySelector('#top-ticker .ticker-text'); // Elemento do texto do letreiro superior
            const bottomTickerText = document.querySelector('#bottom-ticker .ticker-text'); // Elemento do texto do letreiro inferior

            const painelContentDiv = document.getElementById('painel-content'); // Container que tem os Quadros 1 e 2
            const midiaContentDiv = document.getElementById('midia-content');   // Container que tem o iframe
            const midiaIframe = document.getElementById('midia-iframe');         // O iframe para carregar midia.html

            // Obtém referências aos containers dos Quadros 1 e 2 (necessário para as funções de fetch/display)
            const quadro1 = document.getElementById('quadro1');
            const quadro2 = document.getElementById('quadro2');
            const colunasContainer = document.getElementById('colunasContainer'); // Container Quadro 2
            const registrosEmSeparacaoContainer = document.getElementById('registrosEmSeparacaoContainer'); // Container Quadro 1

            const notificationAudio = document.getElementById('notification-audio'); // Elemento de áudio
            const enableSoundBtn = document.getElementById('enable-sound-btn'); // Botão para ativar som


            // --- Função para tocar o áudio de notificação ---
            function playNotificationSound() {
                if (soundEnabled && notificationAudio) {
                    // Clone o nó de áudio para permitir que vários sons sejam tocados rapidamente
                    const audioClone = notificationAudio.cloneNode();
                    audioClone.play().catch(e => console.warn("Erro ao tocar áudio:", e));
                }
            }

            // --- Listener para o botão de ativar som ---
            enableSoundBtn.addEventListener('click', function() {
                 // Tenta tocar o áudio para "desbloquear" a reprodução no navegador
                 playNotificationSound(); // Toca uma vez para ativar
                 soundEnabled = true; // Define o estado como ativado
                 enableSoundBtn.style.display = 'none'; // Esconde o botão
                 console.log("DEBUG: Som de notificação ativado.");
            });


            // --- Função para enviar mensagem para o iframe da Mídia ---
            function sendMidiaMessage(command, data = null) {
                // Verifica se o iframe foi carregado e se o contentWindow está acessível
                if (midiaIframe && midiaIframe.contentWindow) {
                    const targetOrigin = '*'; // OU window.location.origin;
                    midiaIframe.contentWindow.postMessage(command, targetOrigin);
                    console.log(`DEBUG: Mensagem '${command}' enviada para o iframe.`);
                } else {
                    console.warn(`DEBUG: Não foi possível enviar mensagem '${command}'. iframe não pronto ou inacessível.`);
                }
            }


            // --- Função para alternar para a view do Painel ---
            function switchToPainel() {
                console.log("DEBUG: Alternando para o Painel.");
                if (painelTimer) clearTimeout(painelTimer);
                if (midiaTimer) clearTimeout(midiaTimer);

                // --- Envia mensagem 'pause' para o iframe ANTES de escondê-lo ---
                try {
                    if (midiaIframe && midiaIframe.contentWindow) {
                         midiaIframe.contentWindow.postMessage('pause', '*');
                         console.log("DEBUG: Enviado comando 'pause' para o iframe.");
                     }
                } catch (e) {
                    console.warn("DEBUG: Não foi possível enviar comando 'pause' para o iframe (pode ser normal se iframe não carregou totalmente ou já foi limpado).", e);
                }

                painelContentDiv.style.display = 'flex';
                midiaContentDiv.style.display = 'none';

                isShowingPainel = true;

                painelTimer = setTimeout(switchToMidia, PAINEL_DURATION);
                console.log(`DEBUG: Timer do Painel iniciado (${PAINEL_DURATION / 1000}s). Próxima troca para Mídia em ${PAINEL_DURATION / 1000} segundos.`);
            }


            // --- Função para alternar para a view da Mídia ---
            function switchToMidia() {
                console.log("DEBUG: Alternando para a Mídia.");
                if (painelTimer) clearTimeout(painelTimer);
                if (midiaTimer) clearTimeout(midiaTimer);

                painelContentDiv.style.display = 'none';
                midiaContentDiv.style.display = 'block';

                 try {
                     if (midiaIframe && midiaIframe.contentWindow) {
                          const tempLoadListener = () => {
                              console.log("DEBUG: iframe midia.html carregado (tempLoadListener). Enviando 'resume'.");
                              sendMidiaMessage('resume');
                              midiaIframe.removeEventListener('load', tempLoadListener);
                          };

                          if (midiaIframe.contentWindow && midiaIframe.contentWindow.document && (midiaIframe.contentWindow.document.readyState === 'complete' || midiaIframe.contentWindow.document.readyState === 'interactive')) {
                               console.log("DEBUG: iframe midia.html já estava pronto (readyState). Enviando 'resume' imediatamente.");
                               sendMidiaMessage('resume');
                           } else {
                               midiaIframe.addEventListener('load', tempLoadListener);
                               console.log("DEBUG: iframe midia.html ainda não pronto. Adicionado tempLoadListener para enviar 'resume'.");
                           }

                         } else {
                             console.warn("DEBUG: Não foi possível enviar comando 'resume' para o iframe (iframe ou contentWindow não acessível).");
                             if (midiaIframe) {
                                 console.warn("DEBUG: Fallback: Recarregando iframe devido a falha ao enviar 'resume'.");
                                 midiaIframe.src = '/midia'; // Recarrega o iframe para tentar novamente
                               }
                         }
                     } catch (e) {
                         console.warn("DEBUG: Erro ao tentar enviar comando 'resume' para o iframe.", e);
                          if (midiaIframe) {
                              console.warn("DEBUG: Fallback: Recarregando iframe devido a exceção.", e);
                              midiaIframe.src = '/midia'; // Recarrega o iframe em caso de erro
                            }
                     }


                isShowingPainel = false;

                midiaTimer = setTimeout(switchToPainel, MIDIA_DURATION);
                 console.log(`DEBUG: Timer da Mídia iniciado (${MIDIA_DURATION / 1000}s). Próxima troca para Painel em ${MIDIA_DURATION / 1000} segundos.`);
            }


            // --- Função para buscar e exibir dados No-Show (Quadro 2) ---
            async function fetchAndDisplayNoShow() {
                try {
                    // Chamando a rota API correta para registros 'Aguardando Motorista'
                    const response = await fetch('/api/noshow/aguardando-motorista');
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, details: ${errorText}`);
                    }
                    const allAguardandoMotoristaRecords = await response.json();

                    // --- DEBUG LOG: Mostra todos os registros retornados pela API ---
                    console.log("DEBUG fetchAndDisplayNoShow: Registros retornados pela API /api/noshow/aguardando-motorista:", allAguardandoMotoristaRecords);

                    // MODIFICAÇÃO AQUI: Mudando os títulos das ruas
                    const ruaDataValueToColumnTitle = { '1': 'R 1', '2': 'R 2', '3': 'R 3' };
                    const validRuaDataValues = Object.keys(ruaDataValueToColumnTitle);

                    // Filtra e agrupa os registros pela rua (apenas 1, 2, 3)
                    const filteredRecordsForColumns = allAguardandoMotoristaRecords.filter(record => {
                        // Garante que 'rua' existe e é um dos valores válidos
                        const ruaDataValue = record.rua ? String(record.rua).trim() : '';
                        const isValid = validRuaDataValues.includes(ruaDataValue);
                        // --- DEBUG LOG: Mostra se o registro foi filtrado e porquê ---
                        if (!isValid) {
                            console.log(`DEBUG fetchAndDisplayNoShow: Filtrando registro (rua inválida/ausente):`, record);
                        }
                        return isValid;
                    });

                    // --- DEBUG LOG: Mostra os registros após a filtragem ---
                    console.log("DEBUG fetchAndDisplayNoShow: Registros após filtragem por rua:", filteredRecordsForColumns);


                    const groupedByRuaDataValue = {};
                    validRuaDataValues.forEach(value => { groupedByRuaDataValue[value] = []; }); // Garante que todas as ruas (1, 2, 3) existam no objeto
                    filteredRecordsForColumns.forEach(record => {
                         const ruaDataValue = String(record.rua).trim();
                         if (groupedByRuaDataValue[ruaDataValue]) {
                             groupedByRuaDataValue[ruaDataValue].push(record);
                         }
                    });

                    const totalRegistrosParaExibir = filteredRecordsForColumns.length;

                    // --- DEBUG LOG: Mostra o total de registros que serão exibidos ---
                    console.log("DEBUG fetchAndDisplayNoShow: Total de registros para exibir no Quadro 2:", totalRegistrosParaExibir);

                    // --- Lógica de Notificação Sonora para Quadro 2 ---
                    const currentNoShowRecordIds = filteredRecordsForColumns.map(registro => registro.id);
                    if (lastNoShowRecordIds.length > 0) { // Só verifica se já houve uma busca anterior
                        const newNoShowRecordsAppeared = currentNoShowRecordIds.some(id => !lastNoShowRecordIds.includes(id));
                        if (newNoShowRecordsAppeared) {
                            console.log("DEBUG: NOVO registro No-Show detectado!");
                            playNotificationSound();
                        }
                    }
                    lastNoShowRecordIds = currentNoShowRecordIds; // Atualiza a lista de IDs


                    if (totalRegistrosParaExibir > 0) {
                         // Se houver registros para exibir no Quadro 2, ajusta larguras e mostra Quadro 2
                         quadro1.style.width = 'calc(100% - 45%)';
                         quadro1.style.flexGrow = '0';
                         quadro2.style.width = '45%';
                         quadro2.style.flexShrink = '0';
                         quadro2.style.display = 'flex'; // Garante que o Quadro 2 seja exibido

                         colunasContainer.innerHTML = ''; // Limpa o conteúdo atual das colunas

                         const displayLimit = 12; // Limite de exibição por coluna antes do "+N registros"

                         // Itera pelas ruas válidas para criar as colunas
                         validRuaDataValues.forEach(ruaDataValue => {
                             const colunaTitle = ruaDataValueToColumnTitle[ruaDataValue];
                             const recordsForThisRua = groupedByRuaDataValue[ruaDataValue]; // Registros para esta rua

                             const col = document.createElement('div');
                             col.className = 'coluna';
                             // MODIFICAÇÃO AQUI: Adiciona o título da coluna em negrito com a contagem de rotas
                             col.innerHTML = `<h3><strong>${colunaTitle}</strong> (${recordsForThisRua.length} Rotas)</h3>`;

                             // Exibe os registros para esta rua, respeitando o limite
                             const recordsToDisplayInitially = recordsForThisRua.slice(0, displayLimit);
                             if (recordsToDisplayInitially && recordsToDisplayInitially.length > 0) {
                                 recordsToDisplayInitially.forEach(record => {
                                     // Exibir apenas a Rota e " - Liberada"
                                     col.innerHTML += `
                                         <div class="registro">
                                             <div class="rotulo"><span>Rota:</span> ${record.gaiola || 'N/A'} - Liberada</div>
                                         </div>
                                     `;
                                 });

                                 // Adiciona a mensagem de mais registros se houver
                                 if (recordsForThisRua.length > displayLimit) {
                                     col.innerHTML += `<p style="text-align:center; font-size:0.8em; margin-top:10px;">+${recordsForThisRua.length - displayLimit} registros aguardando... (total ${recordsForThisRua.length})</p>`;
                                 }
                             } else {
                                 // Mensagem se não houver registros para esta rua específica
                                 col.innerHTML += `<p>Nenhum registro para ${colunaTitle}.</p>`;
                             }
                             colunasContainer.appendChild(col); // Adiciona a coluna ao container de colunas
                         });

                    } else {
                        // Se não houver registros para exibir no Quadro 2, esconde Quadro 2 e expande Quadro 1
                        colunasContainer.innerHTML = ''; // Limpa o conteúdo
                        quadro1.style.width = '100%';
                        quadro1.style.flexGrow = '1';
                        quadro2.style.width = '0%';
                        quadro2.style.flexShrink = '1';
                        quadro2.style.display = 'none'; // Esconde o quadro 2
                         console.log("DEBUG fetchAndDisplayNoShow: Nenhum registro para exibir no Quadro 2. Ocultando Quadro 2.");
                    }
                } catch (error) {
                    console.error('Erro ao buscar dados No-Show:', error);
                    colunasContainer.innerHTML = '<p class="error-message">Erro ao carregar dados No-Show.</p>';
                    // Em caso de erro, pode ser útil mostrar ambos os quadros com mensagens de erro
                    // Mantém o layout dividido para mostrar o erro no Quadro 2, se Quadro 1 tiver dados
                    // Se Quadro 1 também tiver erro, ele exibirá sua própria mensagem de erro
                    quadro1.style.width = 'calc(100% - 45%)'; // Mantém espaço para Quadro 2 mesmo com erro
                    quadro1.style.flexGrow = '0';
                    quadro2.style.width = '45%';
                    quadro2.style.flexShrink = '0';
                    quadro2.style.display = 'flex'; // Garante que o quadro 2 esteja visível para mostrar o erro
                }
            }


            // --- Função para buscar e exibir registros 'Em Separação' (Quadro 1) ---
            async function fetchAndDisplayRegistrosEmSeparacao() {
                try {
                    const response = await fetch('/api/registros/em-separacao');
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, details: ${errorText}`);
                    }
                    const registros = await response.json();
                    const currentEmSeparacaoRecordIds = registros.map(registro => registro.id);

                    // --- Lógica para detectar novos registros e tocar som ---
                    if (lastEmSeparacaoRecordIds.length > 0) { // Só verifica se já houve uma busca anterior
                        const newRecordsAppeared = currentEmSeparacaoRecordIds.some(id => !lastEmSeparacaoRecordIds.includes(id));
                        if (newRecordsAppeared) {
                            console.log("DEBUG: NOVO registro 'Em Separação' detectado!");
                            playNotificationSound();
                             // Interrompe a mídia e volta para o painel se um novo registro aparecer e a mídia estiver ativa
                             if (!isShowingPainel) {
                                console.log("DEBUG: Interrompendo Mídia para mostrar novo registro 'Em Separação'.");
                                switchToPainel();
                             }
                        }
                    }
                    lastEmSeparacaoRecordIds = currentEmSeparacaoRecordIds; // Atualiza a lista de IDs


                    registrosEmSeparacaoContainer.innerHTML = ''; // Limpa o conteúdo atual
                    if (registros && registros.length > 0) {
                         registros.forEach(registro => {
                             // Exibir Rota e Tipo de Entrega no Quadro 1
                             registrosEmSeparacaoContainer.innerHTML += `
                                 <div class="registro-quadro1">
                                     <p><strong>Nome:</strong> ${registro.nome || 'N/A'}</p>
                                     <p><strong>Rota:</strong> ${registro.rota || 'N/A'} - ${registro.tipo_entrega || 'N/A'}</p>
                                     <p><strong>Gaiola:</strong> ${registro.gaiola || 'N/A'} <strong>Estação:</strong> ${registro.estacao || 'N/A'}</p>
                                 </div>
                             `;
                         });
                     } else {
                         registrosEmSeparacaoContainer.innerHTML = '<p style="text-align: center;">Nenhum registro "Em Separação".</p>';
                     }
                } catch (error) {
                    console.error('Erro ao buscar registros "Em Separação":', error);
                    registrosEmSeparacaoContainer.innerHTML = '<p class="error-message">Erro ao carregar registros "Em Separação".</p>';
                }
            }

            // --- Função para buscar e atualizar o letreiro superior com notícias (CNN Brasil) ---
            async function fetchNewsHeadlines() {
                console.log("DEBUG: Fetching news headlines (CNN Brasil)...");
                try {
                    const response = await fetch('/api/get_news_headlines'); // Rota no Flask
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, details: ${errorText}`);
                    }
                    const data = await response.json();
                    console.log("DEBUG: News headlines received:", data.headlines);

                    if (data.headlines && data.headlines.length > 0) {
                        const combinedText = data.headlines.join(' | ');
                        topTickerText.textContent = combinedText;
                         // Ajusta a duração da animação com base no comprimento do texto
                         const textLength = combinedText.length;
                         const duration = Math.max(20, textLength * 0.15); // Duração mínima de 20s, aumenta com o texto
                         topTickerText.style.animationDuration = `${duration}s`;

                    } else {
                        topTickerText.textContent = "Nenhuma notícia disponível no momento.";
                         topTickerText.style.animationDuration = '20s'; // Duração padrão se não houver texto
                    }
                } catch (error) {
                    console.error('Erro ao buscar notícias:', error);
                    topTickerText.textContent = "Erro ao carregar notícias.";
                     topTickerText.style.animationDuration = '20s'; // Duração padrão em caso de erro
                }
            }
             // --- FIM: Função para buscar notícias ---


            // --- Função para buscar e atualizar o letreiro inferior com informações operacionais ---
            // ATENÇÃO: A rota /api/operational_info causou erro 404 nos logs anteriores.
            // Você precisa implementar essa rota no seu Flask ou remover a chamada se não for usá-la.
             async function fetchOperationalInfo() {
                  console.log("DEBUG: Fetching operational info...");
                  try {
                       // Substitua pela SUA rota API no Flask para informações operacionais
                       // OU remova este fetch e defina o texto manualmente ou com outra lógica
                       const response = await fetch('/api/operational_info'); // <<-- VERIFIQUE ESTA ROTA NO FLASK

                       if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`HTTP error! status: ${response.status}, details: ${errorText}`);
                       }

                       const data = await response.json();
                       console.log("DEBUG: Operational info received:", data.info);

                       // Dentro da função fetchOperationalInfo
if (data.info) {
    bottomTickerText.textContent = data.info;
    const textLength = data.info.length;
    // Ajuste aqui: Defina a duração mínima para 180 segundos (3 minutos)
    // O fator de multiplicação (0.30 no seu código) também pode ser ajustado se o texto for muito curto
    // e você sentir que ele ainda está rápido. Um valor maior deixará ainda mais lento.
    const duration = Math.max(180, textLength * 0.30); // Aumentado para 180 segundos
    bottomTickerText.style.animationDuration = `${duration}s`;
} else {
    bottomTickerText.textContent = "Nenhuma informação operacional disponível.";
    bottomTickerText.style.animationDuration = '180s'; // Garante 3 minutos mesmo sem info
}
// No bloco catch da função fetchOperationalInfo
} catch (error) {
    console.error('Erro ao buscar informações operacionais:', error);
    const fallbackText = "HUB Muriaé Informa: Rotas No-Show já estão liberadas para carregamento imediato! Procure o Analista de Transporte para mais orientações. | Carregamento Mercadão! As rotas liberadas para Carregamento ja estão disponiveis, dirija-se até sua Estação.";
    bottomTickerText.textContent = fallbackText;
    const textLength = fallbackText.length;
    // Ajuste aqui: Defina a duração mínima para 180 segundos (3 minutos)
    // O fator de multiplicação (0.30 no seu código) pode ser ajustado para algo como 0.50 ou mais
    // se o texto de fallback for curto e você ainda sentir que ele passa rápido demais.
    const duration = Math.max(180, textLength * 0.50); // Aumentado para 180 segundos e fator ajustado
    bottomTickerText.style.animationDuration = `${duration}s`;
}
              }
             // --- FIM: Função para buscar informações operacionais ---


            // --- Configuração Inicial e Timers ---

            // --- Carrega o iframe da Mídia uma vez no início, mas o mantém oculto ---
            if (midiaIframe) {
                 midiaIframe.src = '/midia';
                 midiaContentDiv.style.display = 'none'; // Garante que começa oculto

                 // O listener onload para a primeira carga do iframe foi movido para switchToMidia
                 // para garantir que o comando 'resume' seja enviado após a primeira carga COMPLETA
                 // e a Mídia esteja pronta para recebê-lo.
            } else {
                 console.error("DEBUG: Iframe com id 'midia-iframe' não encontrado!");
            }

            // Inicia os fetches de background para os dados dos Quadros 1 e 2 (a cada 1s)
            setInterval(fetchAndDisplayNoShow, FETCH_INTERVAL);
            setInterval(fetchAndDisplayRegistrosEmSeparacao, FETCH_INTERVAL);

             // Frequência de atualização das notícias (busca no Flask) - 3 minutos
             fetchNewsHeadlines(); // Busca inicial ao carregar a página
             setInterval(fetchNewsHeadlines, NEWS_FETCH_INTERVAL); // <-- Atualiza notícias a cada 3 minutos (180000 ms)


             fetchOperationalInfo(); // Busca inicial ao carregar a página
             setInterval(fetchOperationalInfo, OPERATIONAL_INFO_FETCH_INTERVAL); // Exemplo: Atualiza info operacional a cada 30 segundos. VERIFIQUE SE ESSA ROTA EXISTE.


            // --- Lógica para exibir o botão de ativar som se necessário ---
            // Tenta tocar um som mudo para ver se a interação é necessária
            notificationAudio.volume = 0; // Define o volume para 0 para não fazer barulho
            notificationAudio.play().then(() => {
                // Autoplay permitido, som já está "desbloqueado"
                soundEnabled = true;
                console.log("DEBUG: Autoplay permitido. Som de notificação ativado automaticamente.");
                // Não precisa mostrar o botão
            }).catch(() => {
                // Autoplay bloqueado, precisa de interação do usuário
                soundEnabled = false;
                enableSoundBtn.style.display = 'block'; // Mostra o botão para o usuário clicar
                console.log("DEBUG: Autoplay bloqueado. Botão 'Ativar Som' visível.");
                notificationAudio.volume = 1; // Restaura o volume para quando for ativado pelo botão
            });


            // Inicia o ciclo de alternância mostrando o Painel primeiro
            // A primeira chamada a switchToPainel agora será feita após a verificação de autoplay
            // ou após o clique no botão de ativar som, se necessário.
            // Para garantir que o Painel seja exibido mesmo que o som não seja ativado,
            // podemos iniciar o ciclo de alternância aqui, mas a reprodução da mídia
            // só começará após o 'resume' (que depende da ativação do som).
            switchToPainel();


        }); // Fim DOMContentLoaded
    </script>

</body>
</html>
